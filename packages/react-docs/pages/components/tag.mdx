# Tag

`Tag` is used for items that need to be labeled, categorized, or organized using keywords that describe them.

## Import

```js
import { Tag } from '@tonic-ui/react';
```

## Usage

```jsx
<Tag>Sample Tag</Tag>
```

### Variants

Use the `variant` prop to change the visual style of the `Tag`. You can set the value to `solid`, `outline`.

```jsx
<Stack direction="row" spacing="2x" shouldWrapChildren>
  <Tag variant="solid">Solid Tag</Tag>
  <Tag variant="outline">Outline Tag</Tag>
</Stack>
```

### Colors

The color of the tag can be changed by passing the `backgroundColor`, `borderColor`, and `color` props. See the [colors](../system/colors) section to learn more about colors.

```jsx
function Example() {
  const [colorMode] = useColorMode();
  const colors = {
    dark: [
      {
        label: 'Light gray',
        backgroundColor: 'gray:70',
        color: 'gray:20'
      },
      {
        label: 'Red',
        backgroundColor: 'red:80',
        color: 'red:20'
      },
      {
        label: 'Magenta',
        backgroundColor: 'magenta:80',
        color: 'magenta:20'
      },
      {
        label: 'Purple',
        backgroundColor: 'purple:80',
        color: 'purple:20'
      },
      {
        label: 'Blue',
        backgroundColor: 'blue:80',
        color: 'blue:20'
      },
      {
        label: 'Green',
        backgroundColor: 'green:70',
        color: 'green:20'
      },
      {
        label: 'Teal',
        backgroundColor: 'teal:70',
        color: 'teal:20'
      },
      {
        label: 'Cyan',
        backgroundColor: 'cyan:70',
        color: 'cyan:20'
      },
    ],
    light: [
      {
        label: 'Light gray',
        backgroundColor: 'gray:20',
        color: 'black:emphasis'
      },
      {
        label: 'Red',
        backgroundColor: 'red:20',
        color: 'red:100'
      },
      {
        label: 'Magenta',
        backgroundColor: 'magenta:20',
        color: 'magenta:100'
      },
      {
        label: 'Purple',
        backgroundColor: 'purple:20',
        color: 'purple:100'
      },
      {
        label: 'Blue',
        backgroundColor: 'blue:20',
        color: 'blue:100'
      },
      {
        label: 'Green',
        backgroundColor: 'green:20',
        color: 'green:100'
      },
      {
        label: 'Teal',
        backgroundColor: 'teal:20',
        color: 'teal:100'
      },
      {
        label: 'Cyan',
        backgroundColor: 'cyan:20',
        color: 'cyan:100'
      },
    ]
  }[colorMode];

  return (
    <Stack spacing="4x">
      <Stack direction="row" spacing="2x" shouldWrapChildren>
        {colors.map(({ backgroundColor, color, label }, index) => (
          <Tag key={label} backgroundColor={backgroundColor} color={color} variant="solid">{label}</Tag>
        ))}
      </Stack>
      <Stack direction="row" spacing="2x" shouldWrapChildren>
        {colors.map(({ backgroundColor, color, label }, index) => (
          <Tag key={label} backgroundColor={backgroundColor} color={color} variant="solid" borderRadius="lg">{label}</Tag>
        ))}
      </Stack>
      <Stack direction="row" spacing="2x" shouldWrapChildren>
        {colors.map(({ backgroundColor, color, label }, index) => (
          <Tag key={label} borderColor={backgroundColor} color={color} variant="outline">{label}</Tag>
        ))}
      </Stack>
      <Stack direction="row" spacing="2x" shouldWrapChildren>
        {colors.map(({ backgroundColor, color, label }, index) => (
          <Tag key={label} borderColor={backgroundColor} color={color} variant="outline" borderRadius="lg">{label}</Tag>
        ))}
      </Stack>
    </Stack>
  );
}
```

### Sizes

Use the `size` prop to change the size of the `Tag`. You can set the value to `sm`, `md`, or `lg`.

```jsx
<Stack spacing="4x">
  <Stack alignItems="center" direction="row" spacing="2x">
    <Tag size="sm">Small</Tag>
    <Tag size="md">Medium</Tag>
    <Tag size="lg">Large</Tag>
  </Stack>
  <Stack alignItems="center" direction="row" spacing="2x">
    <Tag size="sm" variant="outline">Small</Tag>
    <Tag size="md" variant="outline">Medium</Tag>
    <Tag size="lg" variant="outline">Large</Tag>
  </Stack>
</Stack>
```

### States

```jsx
<Stack spacing="4x">
  <Stack direction="row" spacing="4x" shouldWrapChildren>
    <Tag isClosable>Normal</Tag>
    <Tag isClosable disabled>Disabled</Tag>
    <Tag isClosable isInvalid>Invalid</Tag>
    <Tag isClosable borderRadius="lg">Normal</Tag>
    <Tag isClosable borderRadius="lg" disabled>Disabled</Tag>
    <Tag isClosable borderRadius="lg" isInvalid>Invalid</Tag>
  </Stack>
  <Stack direction="row" spacing="4x" shouldWrapChildren>
    <Tag variant="outline" isClosable>Normal</Tag>
    <Tag variant="outline" isClosable disabled>Disabled</Tag>
    <Tag variant="outline" isClosable isInvalid>Invalid</Tag>
    <Tag variant="outline" isClosable borderRadius="lg">Normal</Tag>
    <Tag variant="outline" isClosable borderRadius="lg" disabled>Disabled</Tag>
    <Tag variant="outline" isClosable borderRadius="lg" isInvalid>Invalid</Tag>
  </Stack>
</Stack>
```

### Add and edit tag

```jsx noInline
const TagCreator = ({
  onCreate,
  ...reset
}) => {
  const [colorMode] = useColorMode();
  const color = {
    dark: 'white:secondary',
    light: 'black:secondary',
  }[colorMode];

  const [inputVisible, setInputVisible] = React.useState(false);
  const handleInputVisible = () => setInputVisible(true);
  const handleInputHidden = () => setInputVisible(false);
  const handleInputBlur = (e) => {
    e.stopPropagation();
    const value = e.target.value;
    onCreate(value);
    handleInputHidden();
  };
  const handleInputKeyUp = (e) => {
    const keyCode = e.keyCode;
    if (keyCode === 13) { // Enter
      const value = e.target.value;
      onCreate(value);
      handleInputHidden();
    }
    if (keyCode === 27) { // Escape
      handleInputHidden();
    }
  };

  if (inputVisible) {
    return (
      <InputBase
        autoFocus
        height="28px"
        verticalAlign="top"
        onKeyUp={handleInputKeyUp}
        onBlur={handleInputBlur}
      />
    );
  }

  return (
    <Box
      display="inline-flex"
      alignItems="center"
      borderRadius="sm"
      border="1px dotted"
      borderColor={color}
      py="1x"
      px="2x"
      onClick={handleInputVisible}
    >
      <Icon icon="add" color={color} />
      <Space width="1x" />
      <Text color={color} fontSize="xs" lineHeight="xs">Add</Text>
    </Box>
  );
};

const TagEditor = ({
  children,
  tagIndex,
  onClose,
  onUpdate,
  ...reset
}) => {
  const tagInputRef = React.useRef();
  const tagHiddenSpanRef = React.useRef();
  const [inputVisible, setInputVisible] = React.useState(false);
  const handleInputVisible = () => setInputVisible(true);
  const handleInputHidden = () => setInputVisible(false);
  const updateTags = (e) => {
    const value = e.target.value;
    onUpdate({ tagIndex, value });
  };
  const handleInputBlur = (e) => {
    updateTags(e);
    handleInputHidden();
  };
  const handleInputKeyUp = (e) => {
    const keyCode = e.keyCode;
    if (keyCode === 13) { // Enter
      updateTags(e);
      handleInputHidden();
    }
    if (keyCode === 27) { // Esc
      handleInputHidden();
    }
  };
  const handleTagClick = (e) => {
    e.stopPropagation();
    handleInputVisible();
  };
  const handleTagKeyUp = (e) => {
    const keyCode = e.keyCode;
    if (keyCode === 13) { // Enter
      handleInputVisible();
    }
  };
  const handleTagClose = (e) => {
    e.stopPropagation();
    onClose(tagIndex);
  };
  const handleInputResize = () => {
    if (!tagInputRef.current) {
      return;
    }
    const tagInput = tagInputRef.current;
    const tagHiddenSpan = tagHiddenSpanRef.current;
    tagHiddenSpan.textContent = tagInput.value;
    tagInput.style.width = `${tagHiddenSpan.offsetWidth}px`;
    tagInput.focus();
  };

  React.useEffect(() => {
    handleInputResize();
  }, [inputVisible]);

  if (inputVisible) {
    return (
      <>
        <Box
          as="span"
          ref={tagHiddenSpanRef}
          position="absolute"
          height="0"
          overflow="hidden"
          whiteSpace="pre"
        />
        <InputBase
          ref={tagInputRef}
          minHeight="6x"
          maxWidth="100%"
          mr="2x"
          mt="1x"
          defaultValue={children}
          onKeyUp={handleInputKeyUp}
          onBlur={handleInputBlur}
          onInput={handleInputResize}
        />
      </>
    );
  }

  return (
    <Tag
      isClosable
      mr="2x"
      mt="1x"
      verticalAlign="top"
      onClick={handleTagClick}
      onClose={handleTagClose}
      onKeyUp={handleTagKeyUp}
      cursor="pointer"
    >
      <Text
        title={children}
        maxWidth={120}
        overflow="hidden"
        textOverflow="ellipsis"
        whiteSpace="nowrap"
      >
        {children}
      </Text>
    </Tag>
  );
};

const Tags = () => {
  const [tags, setTags] = React.useState([]);
  const createTag = (value) => {
    let newTags = tags;
    if (value && tags.indexOf(value) === -1) {
      newTags = [...tags, value];
    }
    setTags(newTags);
  };
  const updateTag = ({ tagIndex, value }) => {
    let newTags = tags;
    newTags[tagIndex] = value;
    setTags(newTags);
  };
  const handleTagEditorClose = (tagIndex) => {
    tags.splice(tagIndex, 1);
    setTags([...tags]);
  };

  return (
    <>
      {
        tags.map((tag, i) => (
          <TagEditor
            key={i}
            tagIndex={i}
            onClose={handleTagEditorClose}
            onUpdate={updateTag}
          >
            {tag}
          </TagEditor>
        ))
      }
      <TagCreator onCreate={createTag} />
    </>
  );
};

render(<Tags />);
```

### With input

- For duplicated entries, put both entries invalid, and hover the token to display error message.
- When paste with text with delimiter, automatically convert to tags. Default delimiter: `,`, `;`

```jsx noInline
const useWrapperStyle = ({
  isFocused,
}) => {
  const [colorMode] = useColorMode();
  const borderColor = {
    dark: 'gray:60',
    light: 'gray:30',
  }[colorMode];
  const invalidBorderColor = {
    dark: 'red:50',
    light: 'red:60',
  }[colorMode];
  const focusBorderColor = {
    dark: 'blue:60',
    light: 'blue:60',
  }[colorMode];

  return {
    backgroundColor: 'transparent',
    borderRadius: 'sm',
    fontSize: 'sm',
    lineHeight: 'sm',
    minHeight: '14x',
    px: '3x',
    pb: '1x',
    border: 1,
    borderColor: isFocused ? focusBorderColor : borderColor,
    _invalid: {
      borderColor: invalidBorderColor,
    },
  };
};

const TagCreator = React.forwardRef((
  {
    onBlur,
    onCreate,
    onFocus,
    ...reset
  },
  ref
) => {
  const [inputValue, setInputValue] = React.useState('');
  const createTags = (values) => {
    onCreate(values);
    setInputValue('');
  };
  const handleInputBlur = (e) => {
    e.stopPropagation();
    const value = e.target.value;
    if (value) {
      createTags([value]);
    }
    onBlur(e);
  };
  const handleInputChange = (e) => {
    const value = e.target.value;
    setInputValue(value);
  };
  const handleInputKeyUp = (e) => {
    const keyCode = e.keyCode;
    let value = e.target.value;
    if (keyCode === 13) { // Enter
      createTags([value]);
    }
    if (keyCode === 186 || keyCode === 188) { // Semicolon(;) or Comma(,)
      value = value.substring(0, value.length - 1);
      createTags([value]);
    }
    if (keyCode === 27) { // Esc
      setInputValue('');
    }
  };
  const handleInputPaste = (e) => {
    e.preventDefault();
    const pastedData = e.clipboardData.getData('text');
    const separatedValues = pastedData.split(
      new RegExp([',', ';', '\n', '\r', '\r\n'].join('|'))
    );
    createTags(separatedValues);
  };

  return (
    <InputBase
      ref={ref}
      minHeight="6x"
      value={inputValue}
      onBlur={handleInputBlur}
      onChange={handleInputChange}
      onFocus={onFocus}
      onKeyUp={handleInputKeyUp}
      onPaste={handleInputPaste}
      {...reset}
    />
  );
});

const TagEditor = ({
  children,
  isInvalid,
  tagId,
  onClick,
  onClose,
  onFocus,
  onUpdate,
  ...reset
}) => {
  const tagInputRef = React.useRef();
  const tagHiddenSpanRef = React.useRef();
  const [inputVisible, setInputVisible] = React.useState(false);
  const handleInputVisible = () => setInputVisible(true);
  const handleInputHidden = () => setInputVisible(false);
  const updateTag = (value) => {
    onUpdate({ id: tagId, value });
  };
  const handleInputBlur = (e) => {
    updateTag(e.target.value);
    handleInputHidden();
  };
  const handleInputKeyUp = (e) => {
    const keyCode = e.keyCode;
    if (keyCode === 13) { // Enter
      updateTag(e.target.value);
      handleInputHidden();
    }
    if (keyCode === 27) { // Esc
      handleInputHidden();
    }
  };
  const handleInputResize = () => {
    if (!tagInputRef.current) {
      return;
    }
    const tagInput = tagInputRef.current;
    const tagHiddenSpan = tagHiddenSpanRef.current;
    tagHiddenSpan.textContent = tagInput.value;
    tagInput.style.width = `${tagHiddenSpan.offsetWidth}px`;
    tagInput.focus();
  };

  const handleTagClick = (e) => {
    e.stopPropagation();
    handleInputVisible();
    onClick(tagId);
  };
  const handleTagClose = (e) => {
    e.stopPropagation();
    onClose(tagId);
  };
  const handleTagKeyUp = (e) => {
    const keyCode = e.keyCode;
    if (keyCode === 13) {
      handleInputVisible();
    }
  };

  React.useEffect(() => {
    handleInputResize();
  }, [inputVisible]);

  if (inputVisible) {
    return (
      <>
        <Box
          as="span"
          ref={tagHiddenSpanRef}
          position="absolute"
          height="0"
          overflow="hidden"
          whiteSpace="pre"
        />
        <InputBase
          ref={tagInputRef}
          minHeight="6x"
          maxWidth="100%"
          mr="2x"
          mt="1x"
          defaultValue={children}
          onBlur={handleInputBlur}
          onInput={handleInputResize}
          onKeyUp={handleInputKeyUp}
        />
      </>
    );
  }

  return (
    <Tag
      isClosable
      isInvalid={isInvalid}
      onClick={handleTagClick}
      onClose={handleTagClose}
      onKeyUp={handleTagKeyUp}
      onFocus={onFocus}
      cursor="pointer"
      {...reset}
    >
      <Text
        title={children}
        maxWidth={120}
        overflow="hidden"
        textOverflow="ellipsis"
        whiteSpace="nowrap"
      >
        {children}
      </Text>
    </Tag>
  );
};

const Tags = () => {
  const [colorMode] = useColorMode();
  const placeholderColor = {
    dark: 'white:tertiary',
    light: 'black:tertiary',
  }[colorMode];
  const invalidColor = {
    dark: 'red:50',
    light: 'red:60',
  }[colorMode];

  const [tags, setTags] = React.useState([]);
  const [hasError, setHasError] = React.useState(false);
  const tagCreatorRef = React.useRef();
  const [placeholderVisible, setPlaceholderVisible] = React.useState(true);
  const [isWrapperFocused, setWrapperFocused] = React.useState(false);

  const verifyTag = ({ id, value }) => {
    const isDuplicated = tags.find((t) => t.value === value && t.id !== id);
    if (isDuplicated) {
      return 'Duplicated entries';
    }
    return '';
  };
  const createTags = (values) => {
    if (values.length === 0) {
      return;
    }
    values = values.filter(value => {
      if (value.trim() === '') {
        return false; // skip
      }
      return true;
    }).map((value, i) => {
      const tagId = new Date().getTime() + i;
      return {
        id: tagId,
        value: value,
        isActive: false,
        error: verifyTag({ id: tagId, value: value }),
      };
    });
    const newTags = [...tags, ...values];
    setTags(newTags);
  };
  const updateTag = ({ id, value }) => {
    const newTags = [...tags];
    const tag = newTags.find((t) => t.id === id);
    tag.value = value || tag.value;
    tag.isActive = false;
    tag.error = verifyTag({ id, value });
    setTags(newTags);
  };

  const handleTagCreatorBlur = () => {
    setWrapperFocused(false);
    if (tags.length === 0) {
      setPlaceholderVisible(true);
    }
  };
  const handleTagCreatorFocus = () => {
    setPlaceholderVisible(false);
  };

  const handleTagEditorClick = (tagId) => {
    const newTags = [...tags];
    let tag = newTags.find((t) => t.id === tagId);
    tag.isActive = true;
    setTags(newTags);
  };
  const handleTagEditorClose = (tagId) => {
    const tag = tags.find((t) => t.id === tagId);
    if (!tag) {
      return;
    }
    const newTags = tags.filter((t) => t.id !== tagId);
    setTags(newTags);
    tagCreatorRef.current.focus();
  };
  const handleTagEditorFocus = () => {
    setWrapperFocused(true);
  };

  const handleWrapperClick = (e) => {
    const activeTag = tags.find((t) => t.isActive);
    if (activeTag) {
      return;
    }
    tagCreatorRef.current.focus();
    setWrapperFocused(true);
  };
  const wrapperStyle = useWrapperStyle({
    isFocused: isWrapperFocused,
  });

  React.useEffect(() => {
    const invalidTags = tags.filter(t => t.error.length > 0);
    if (invalidTags.length > 1) {
      setHasError(true);
    }
    if (invalidTags.length === 1 && invalidTags[0].isActive === false) {
      setHasError(true);
    }
    if (invalidTags.length === 0) {
      setHasError(false);
    }
  }, [tags]);

  return (
    <>
      <Box
        {...wrapperStyle}
        role="presentation"
        aria-invalid={hasError}
        onClick={handleWrapperClick}
      >
        {placeholderVisible && <Text mt="1x" color={placeholderColor}>Placeholder text</Text>}
        {
          tags.map(tag => {
            const id = tag.id;
            const value = tag.value;
            const error = tag.error;
            if (error) {
              return (
                <Popover hideArrow key={id} trigger="hover">
                  <PopoverTrigger verticalAlign="top">
                    <TagEditor
                      isInvalid
                      mr="2x"
                      mt="1x"
                      tagId={id}
                      onClick={handleTagEditorClick}
                      onClose={handleTagEditorClose}
                      onFocus={handleTagEditorFocus}
                      onUpdate={updateTag}
                    >
                      {value}
                    </TagEditor>
                  </PopoverTrigger>
                  <PopoverContent>
                    <PopoverBody>{error}</PopoverBody>
                  </PopoverContent>
                </Popover>
              );
            }
            return (
              <TagEditor
                key={id}
                verticalAlign="top"
                mr="2x"
                mt="1x"
                tagId={id}  
                onClick={handleTagEditorClick}
                onClose={handleTagEditorClose}
                onFocus={handleTagEditorFocus}
                onUpdate={updateTag}
              >
                {value}
              </TagEditor>
            );
          })
        }
        <TagCreator
          ref={tagCreatorRef}
          mt="1x"
          onBlur={handleTagCreatorBlur}
          onCreate={createTags}
          onFocus={handleTagCreatorFocus}
        />
      </Box>
      {hasError && <Text color={invalidColor}>There are invalid entries.</Text>}
    </>
  );
};

render(<Tags />);
```

## Props

| Name | Type | Default | Description |
| :--- | :--- | :------ | :---------- |
| disabled | boolean | | If `true`, the tag will be disabled. This sets `aria-disabled=true` and you can style this state by passing the `_disabled` prop. |
| isInvalid | boolean | | If `true`, the tag will indicate an error. You can style this state by passing the `_invalid` prop. |
| isClosable | boolean | | If `true`, a close button will appear on the right side. |
| onClose | function | | A callback called when the close button is clicked. |
| size | string | 'md' | The size of the tag component. One of: 'sm', 'md', 'lg' |
| variant | string | 'solid' | The variant style of the tag component. One of: 'solid', 'outline' |
